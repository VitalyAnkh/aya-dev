# 基于低级语法树的补全

前提：复用语法树，特别是不通过在补全处插入魔法字符的方式来进行补全。

## Step 0: 找到光标处的字符

这个过程相当简单

## Step 1: 重放光标

这个阶段通过将光标放置在更加准确的位置上，特别是在 Aya 中具有相当多的右开放 (right-open) 结构，
例如函数定义 `def foo => a` 和 let 绑定 `let a := b in c` 中的 `a := b`。

这个过程实际上是通过找到左侧第一个 有意义 的 token 来做到的，通常来说，是跳过所有空白 token。
然而并非在所有情况都可以重放光标，我们要知道需要重放光标的情况：

* 由于光标实际上在其所指向的字符的左侧，所以所有指向任何 token 第一个字符的光标都应该被重放。例如 `def foo (a : _Nat)`。
* 所有指向空白字符的光标。例如 `def foo (a :_ Nat)`
  我们不重放：
* 在 token 中间的光标。例如 `def foo (a : N_at)`

## Step 2: 收集绑定及确定位置信息

收集绑定即收集光标所指位置的所有可用的绑定，位置信息指的是光标所指位置的 _类型_，我们需要通过这个类型来决定要提供什么样的补全，
比如在修饰符处不应该提供顶层符号，在表达式处不应该提供与表达式无关的修饰符等。

最后，在收集了这一层的信息之后，应当选择合适的节点继续上一层的信息收集，但有很多情况需要讨论。
在经过 step 1 之后，光标所指的位置可能是：1) 一个普通的语法树节点 2) 一个 0 长度的节点，用来代表光标位置。
然而我们不能：直接使用该节点的父节点，如果该节点是 2)，我们很可能在没有到达正确的层级之前就损失了该节点的信息，比如：
`def foo (a : Nat)_`，
在某次上升的过程中将 `(a : Nat)` 作为节点传入，我们将无法获得关于 `(a : Nat)` 的绑定信息。

实际上，重放光标的过程并不能将光标放置在正确的层级，因此在上升的过程中，我们需要可选地重放光标到正确的层级。
因此，对于一些节点，如果它是一个 0 长度的，用来代表光标位置的节点，那么我们检查它是否仍然在父节点的末尾，如果是，就重新放置光标到父节点的层级。

但是，同样的，我们不能对 **所有** 的节点都进行如此操作，要进行这一操作，光标必须在重放后仍然具有正确的可用绑定，但是一些节点并不满足，
比如 let 绑定 `a := b_`，此时光标在 `b_` 处，进行如上的重放操作后，将变为 `a := b_`，而此时的可用绑定增加了 `a`。

注意到，这些节点本身引入绑定，并且右开放，因此对于这些节点，我们不进行重放操作，而是将光标视为该节点的一部分。

Q: `a : Nat` 也引入定义，但却仍然进行以上操作？
A: 这个语法无法脱离括号存在，在括号下的这个节点不满足右开放特性了。
